## 객체, 설계

- 목적 : 객체지향 프로그래밍을 설계하고, 유지보수하는 데 필요한 원칙과 기법을 설명하기 위함.



### 01 티켓 판매 애플리케이션 구현하기

- 목표는 초대장을 발송하는 것
- 초대장이 있으면 공연을 무료로 관람할 수 있음
- 문제는 초대장이 있는 관람객과, 그렇지 않은 관람객을 **다른 방식** 으로 입장시켜야함.
- 즉 초대장이 없으면, **티켓을 구매** 해야만 입장할 수 있다!
- 관람객이 가지고 올 수 있는 소지품을 3가지
  1. 초대장
  2. 현금
  3. 티켓

- 가방의 상태는 2가지 일 것
  1. 이벤트에 당첨된 관람객의 가방
     - 초대장이 있음
  2. 이벤트에 담청되지 않은 관람객의 가방
     - 초대장이 없음.

- 티켓을 판매할 오피스도 있어야하고,
- 티켓오피스에서 티켓을 판매하거나, 교환할 셀러도 있어야함.



### 02 문제점

- 모든 모듈은 제대로 실행되어야하고, 변경이 용이해야하며, 이해하기 쉬워야함.
- 현재 코드는 제대로 실행됨.
  - 그렇지만 변경이 용이하거나, 이해하기 쉬운 코드는 아니다.
- 문제는 관람객과 판매원이 극장에 통제를 받고 있다.
  - 생각해보면, 극장이 관람객의 가방을 열어볼 수 있을까? 안될듯.
- 극장 클래스 `enter()` 에서 너무 많은 일을 처리하고 있음.



#### 변경에 취약함

- 현재 관람객이 항상 가방을 들고다닌다고 가정하고 있음.
  - 안 가지고 다니는 경우도 있지 않을까?
- 그리고 계산은 현금으로 계산됨. 
  - 만약 신용카드를 이용해서 결제한다면 어떻게 됨?
  - 결제 방식 자체와 이와 연결된 클래스를 바꿔야할 가능성이 높다.
- 즉 객체 간의 의존성이 높음.
  - 다시 말해, 최소한의 의존성만 유지하고, 불필요한 의존성은 제거하는게 좋음.
- `결합도(coupling)` 이 높다는 것은, 객체 사이의 의존성이 과한것을 의미함.
- 결합도가 낮다면, 변경이 용이하다고 볼 수 있음.



### 03 설계 개선하기

- 객체를 자율적인 존재로 만든다
- 즉 필요한 정보들만 알도록 만든다.
- 그리고 객체 자신에서 해결할 일들은 해결하도록 만든다.

---

>  캡슐화

- 개념적으로나 물리적으로나 객체 내부의 세부적인 사항을 감추는 것
- 왜? 변경하기 쉬운 객체를 만들기 위해서
- 객체 내부로의 접근을 제한하면, 객체 간의 결합도를 낮출 수 있기 때문에, 설계를 좀 더 쉽게 변경할 수 있따!

---

- <u>객체를 인터페이스와 구현으로 나누고</u>, 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야할 **가장 기본적인 원칙**

- 객체 자기 자신의 문제를 스스로 해결하도록 코드를 변경해야함.
- 객체 내부의 상태를 캡슐화 하고, 객체간에 오직 메서지를 통해서만 상호작용하도록 만들어야함
- `응집도(cohesion)` 가 높다?
  - 연관된 작업만을 수행하고, 연관성 없는 작언은 다른 객체에게 위임하는 객체를 일컫음.
- 자율적인 객체는 



---

#### 책임의 이동

- 처음 코드는 `Theater` 에서 모든 작업을 도맡아 처리했음.
- 그렇지만 변경된 코드는, 각 객체가 맡은 일을 **스스로** 처리했음.
  - 즉 책임이 적절하게 분배되었음을 의미한다.

---

- 현실에서 수동적인 존재라고 하더라도, 객체 지향 프로그래밍 세계에 들어오면 **능동적이고 자율적인 존재로 바뀐다**
  - 이러한 원칙을 **의인화** 라고 함.



### 04 객체지향 설계

- 좋은 설계란?
  - 기능이 작동해야하고
  - 쉽게 변경할 수 있어야한다.

